////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// https://dmoj.ca/problem/knapsack4
////////////////////////////////////////////////////////////////
// Knapsack 4 Rope Pulling, also known as Tug of War, is a class
// ic game. After acquiring a very very very large tie under sus
// picious circumstances, Zhang3 is using it to organize such a 
// game between mathies and engineers. There are n mathies and m
//  engineers. Participant i has strength w[i] and meme value v[
// i]. To make the game more interesting, Zhang3 wants to choose
//  the teams to have same total strengths, while maximizing the
//  total meme values of all participants. Output the maximum me
// me value possible. Note that empty teams are also allowed. In
// put Specification The first line of the input gives the numbe
// r of test cases, T( 1 <= T <= 30 ). T test cases follow. For 
// each test case, the first line contains two integers, n, m( 1
//  <= n,m <= 1000 ) representing the number of mathies and engi
// neers respectively. Then n + m lines follow, describing the s
// tudents. The i-th line contains two integers w[i], v[i]( 1 <=
//  w[i] <= 1000, -10^9 <= v[i] <= 10^9), representing the stren
// gth and the meme value by the i-th participant. The first n a
// re mathies, while the other m are engineers. The sum of n + m
//  in all test cases doesn't exceed 10^4. Output Specification 
// For each test case, print a line with an integer, representin
// g the maximum total meme value of two teams with the same tot
// al strength values. Sample Input 2 3 4 4 7 3 8 2 2 1 4 5 8 1 
// 3 4 4 1 2 1000 -10000 200 3000 800 5000 Sample Output 30 0
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <iostream>
# include <vector>
# include <algorithm>
# include <utility>
# include <limits>
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# define OVERLOAD_OSTREAM_OPERATOR( Container )                \
template <typename... T>                                       \
ostream& operator<<( ostream& os, const Container<T...>& con ){\
    os << "[ ";                                                \
    for( const auto& y: con ) os << y << " ";                  \
    return os <<"]";                                           \
}
//////////////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////// 
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
OVERLOAD_OSTREAM_OPERATOR( vector );
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
using i64 = long long;
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
inline void VROOOM() {
    ios::sync_with_stdio( false );
    cout.tie( nullptr );
    cin.tie( nullptr );
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
constexpr char nl = '\n';
constexpr char sp = ' ';
constexpr i64 none = numeric_limits<i64>::min();
////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////// 
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
struct Item {
    int w;
    int v;
};
////////////////////////////////////////////////////////////////
ostream& operator<<( ostream& os, const Item& item ){
    return os << "(" << item.w << "," << item.v << ")";
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
i64 knapsack4( int W, vector<Item>& a, vector<Item>& b ){
    int n = a.size();
    vector<i64> f( W + 1, none );
    f[0] = 0;
    for( int i = 0; i < n; ++i ){
        int w8 = a[i].w;
        int vl = a[i].v;
        for( int j = W; j >= w8; --j ){
            if( f[j - w8] == none ){ continue; }
            f[j] = max( f[j], f[j - w8] + vl );
        }
    }
    for(; f[W] == none; --W )
        ;
    if( W == 0 ){ return 0; }
    n = b.size();
    vector<i64> g( W + 1, none );
    g[0] = 0;
    for( int i = 0; i < n; ++i ){
        int w8 = b[i].w;
        int vl = b[i].v;
        for( int j = W; j >= w8; --j ){
            if( g[j - w8] == none ){ continue; }
            g[j] = max( g[j], g[j - w8] + vl );
        }
    }
    i64 total = 0;
    while( W-- ){
        if( f[W] == none or g[W] == none ){ continue; }
        total = max( total, f[W] + g[W] );
    }
    return total;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main() {
    VROOOM();
    if( 0 ){
    } else {
        int t; cin >> t;
        while( t-- ){
            int n, m; cin >> n >> m;
            vector<Item> math( n );
            int total_math_weight = 0;
            for( int j = 0; j < n; ++j ){
                cin >> math[j].w >> math[j].v;
                total_math_weight += math[j].w;
            }
            vector<Item> engr( m );
            int total_engr_weight = 0;
            for( int j = 0; j < m; ++j ){
                cin >> engr[j].w >> engr[j].v;
                total_engr_weight += engr[j].w;
            }
            int W = min( total_math_weight, total_engr_weight );
            if( n > m ){
                swap( math, engr );
            }
            cout << knapsack4( W, math, engr ) << endl;
        }
    }
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Test case #1:                     AC [3.561s, 22.59 MB] (1/1)
// Resources:                                   3.561s, 22.59 MB
// Maximum single-case runtime:                           3.561s
// Final score:                             1/1 (20.0/20 points)
