////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// www.codechef.com/problems/INSQ15_A
////////////////////////////////////////////////////////////////
// The Gift Of Raksha Bandhan
////////////////////////////////////////////////////////////////
// Its time of Raksha Bandhan so its compulsory for every
// brother to give a gift to his sister.  Brother Jon is
// planning to give a string S of length L to his sister Arya.
////////////////////////////////////////////////////////////////
// After receiving the gift from her brother, Arya decided to
// share the string with her brother Jon.
////////////////////////////////////////////////////////////////
// String S contains characters from index 0 to index L - 1.
////////////////////////////////////////////////////////////////
// She will select a pivot called P ie any index
////////////////////////////////////////////////////////////////
// P(1 ≤ P ≤ L - 1) and divides the original string into two
// parts. First part will contain characters from index 0 to
// index P - 1 and second part will contain characters from
// index P to L - 1.
////////////////////////////////////////////////////////////////
// Jon will keep the first part and Arya will keep the second
// part.
////////////////////////////////////////////////////////////////
// Arya is great fan of LCP (Longest Common Prefix) so she
// decided that she will select such an index as pivot such that
// LCP of the two part is high.
////////////////////////////////////////////////////////////////
// Though she like LCP but she does not know how to calculate
// it. Help her to solve the problem.
////////////////////////////////////////////////////////////////
// Arya will ask you Q questions. Each question is represented
// by a index P and you have to answer the LCP (Longest Common
// Prefix) of the two parts.
////////////////////////////////////////////////////////////////
// Input
////////////////////////////////////////////////////////////////
// First line of input contains a string S.
////////////////////////////////////////////////////////////////
// Second line of input contains a positive number Q
// representing the number of question Arya will ask you. Q
// lines will follow each containing a positive number P
////////////////////////////////////////////////////////////////
// Output
////////////////////////////////////////////////////////////////
// Output Q numbers(the required answer). Each number on a
// separate line.
////////////////////////////////////////////////////////////////
// Constraints
////////////////////////////////////////////////////////////////
// 1 ≤ Length of the string(or L) ≤ 5 * 10^6
// 1 ≤ P ≤ L - 1
// 1 ≤ Q(number of queries) ≤ 10^6
////////////////////////////////////////////////////////////////
// All characters in the string will be small case english
// alphabets (a-z)
////////////////////////////////////////////////////////////////
// NOTE: C++ users, please do not use cin and cout as test cases
// are huge, prefer scanf and printf
////////////////////////////////////////////////////////////////
// Example
// Input:
// abababa
// 4
// 1
// 2
// 3
// 6
// Output:
// 0
// 2
// 0
// 1
////////////////////////////////////////////////////////////////
// Explanation
////////////////////////////////////////////////////////////////
// For the first query, first part is a.and second part is
// bababa, hence LCP is 0.
////////////////////////////////////////////////////////////////
// For the second query, first part is ab.and second part is
// ababa, hence LCP is 2.
////////////////////////////////////////////////////////////////
// For the third query, first part is aba.and second part is
// baba, hence LCP is 0.
////////////////////////////////////////////////////////////////
// For the fourth query, first part is ababab.and second part is
// a, hence LCP is 1.
////////////////////////////////////////////////////////////////
// More Info
// Time limit 2 secs
// Memory limit 1.5 GB
// Source Limit 50000 Bytes
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <iostream>
# include <vector>
# include <string>
# include <algorithm>
# include <utility>
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
# define OVERLOAD_OSTREAM_OPERATOR( Container )                \
template <typename... T>                                       \
ostream& operator<<( ostream& os, const Container<T...>& con ){\
    os << "[ ";                                                \
    for( const auto& y: con ) os << y << " ";                  \
    return os << "]";                                          \
}
////////////////////////////////////////////////////////////////
OVERLOAD_OSTREAM_OPERATOR( vector );
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
typedef unsigned long long u64;
////////////////////////////////////////////////////////////////
constexpr u64 P = 31;
constexpr u64 M = 1'000'000'009;
////////////////////////////////////////////////////////////////
char S[5'000'001]; // vrooom
vector<u64> p; // powers
vector<u64> h; // hashed prefixes
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
void precompute( int n, char* S ){
    p.resize( n );
    h.resize( n + 1 );
    p[0] = 1;
    for( int i = 1; i < n; ++i ){
        p[i] = p[i - 1] * P % M;
    }
    h[0] = 0;
    for( int i = 0; i < n; ++i ){
        u64 y = (S[i] - 'a' + 1) * p[i] % M;
        h[i + 1] = (h[i] + y) % M;
    }
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//    ------------
// S: 0 1 .. (P-1) P (P+1) .. (n-1)
//                 ================
int binary_search( int P ){
    const int n = p.size();
    int l = 1;
    int u = min( P, n - P );
    while( l <= u ){
        int m = (l + u)/ 2;
        // left S[0 .. (m - 1)]
        // ryte S[P .. (P + m - 1)]
        u64 ryte = (h[P + m] + M - h[P]) % M;
        u64 left = h[m] * p[P] % M;
        if( left == ryte ){
            l = m + 1;
        } else {
            u = m - 1;
        }
    }
    return u;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main() {
    int Q;
    int P;
    int n;
    scanf( "%s%n", S, &n );
    scanf( "%d", &Q );
    precompute( n, S );
    while( Q-- ){
        scanf( "%d", &P );
        printf( "%d\n", binary_search( P ));
    }
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// The gray light barely made its way through the mist
// moving slowly through the white birches
// down to the quiet depths of the Black Mountain
// A land covered with wild clover and whispering moss
//
// From the nearby forest came the bark of a Hell Hound
// The Gnoll stood still, sniffing the cold air
// Fate called
// With claws sunk deep in the red earth
// He answered
//
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Result                                                Correct
