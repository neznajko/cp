////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Gray Code
////////////////////////////////////////////////////////////////
// Time limit: 1.00 s
// Memory limit: 512 MB
////////////////////////////////////////////////////////////////
// A Gray code is a list of all 2^n bit strings of length n,
// where any two successive strings differ in exactly one bit
// (i.e., their Hamming distance is one).  Your task is to
// create a Gray code for a given length n.
////////////////////////////////////////////////////////////////
// Input
// The only input line has an integer n.
// Output
// Print 2^n lines that describe the Gray code. You can print
// any valid solution.
////////////////////////////////////////////////////////////////
// Constraints
// 1 <= n <= 16
////////////////////////////////////////////////////////////////
// Example
// Input:
// 2
// Output:
// 00
// 01
// 11
// 10
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <bits/stdc++.h>
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
using i32 = int;
using u32 = unsigned int;
using i64 = long long;
using u64 = unsigned long long;
using vi32 = vector<i32>;
using vu32 = vector<u32>;
using vi64 = vector<i64>;
using vu64 = vector<u64>;
using vb8l = vector<bool>;
using vstr = vector<string>;
////////////////////////////////////////////////////////////////
constexpr char nl = '\n';
constexpr char sp = ' ';
constexpr char tab = '\t';
constexpr u64 mod1 = 1'000'000'007;
////////////////////////////////////////////////////////////////
template <typename T>
istream& operator>>( istream& is, vector<T>& v ){
    for( auto& y: v ){ is >> y; }
    return is;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
inline void vrooom() {
    cin.tie( nullptr )->sync_with_stdio( false );
}
////////////////////////////////////////////////////////////////
template <typename T>
inline T load_scalar() {
    T y; cin >> y;
    return y;
}
////////////////////////////////////////////////////////////////
template <typename T>
inline vector<T> load_vector( int n ) {
    vector<T> y( n ); cin >> y;
    return y;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
string OPEN_BRACKET = "[";
string CLOSE_BRACKET = "]";
string SEPARATOR = ",";
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# define OVERLOAD_OSTREAM_OPERATOR( Container )                \
template <typename... T>                                       \
ostream& operator<<( ostream& os, const Container<T...>& con ){\
    os << OPEN_BRACKET;                                        \
    string sep = "";                                           \
    for( const auto& y: con ){                                 \
        os << sep << y;                                        \
        sep = SEPARATOR;                                       \
    }                                                          \
    return os << CLOSE_BRACKET;                                \
}
////////////////////////////////////////////////////////////////
OVERLOAD_OSTREAM_OPERATOR( vector );
////////////////////////////////////////////////////////////////
# define FOR_THE_HORDE auto t = load_scalar<u32>(); while( t-- )
# define PSH push_back
# define POP pop_back
# define odd( x ) ((x) & 1)
# define evn( y ) (!odd( y ))
# define sqr( x ) ((x) * (x))
# define all( x ) x.begin(), x.end()
# define siz( y ) y.size()
# define dbg( x ) cerr << #x << " = " << x << nl
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// 0 00 000 code = [ 0, 1 ]                |[0,1], n = 3
// 1 10 100 for i = 1; i < n; ++i          |i=1, siz=2
//   11 110   siz = code.siz               |j=[0,2) [00,10]
//   01 010   for j = 0; j < siz; ++j      |j=[1,0] [00,10,11,01]
//      011     code[j] <<= 1              |i=2, siz=4
//      111   for j = siz - 1; j >= 0; --j |j=[0,4) [000,100,110,010]
//      101     code.push( code[j] | 1 )   |j=[3,0] [000,100,110,010,011,111,101,001]
//      001                                |
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
class Algorithm {
public:
    Algorithm( u32 n ):
        n( n )
    {}
    void pusk() {
        vi32 code{ 0, 1 };
        for( i32 i = 1; i < n; ++i ){
            i32 siz = siz( code );
            for( i32 j = 0; j < siz; ++j ){
                 code [j] <<= 1;
            }
            for( i32 j = siz - 1; j >= 0; --j ){
                code.PSH( code [j] | 1 );
            }
        }
        for( auto y: code ){
            cout << binary( y, n ) << nl;
        }
    }
private:
    const u32 n;
    static string binary( i32 number, u32 length ){
        bitset<32> bits( number );
        return bits.to_string().substr( 32 - length );
    }
};
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main() {
    vrooom();
    if( 0 ){
    } else {
        auto n = load_scalar<u32>();
        Algorithm( n ).pusk();
    }
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
