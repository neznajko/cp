////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Permutations
// Time limit: 1.00 s
// Memory limit: 512 MB
// A permutation of integers 1,2,...,n is called beautiful if
// there are no adjacent elements whose difference is 1. Given
// n, construct a beautiful permutation if such a permutation
// exists.
// Input
// The only input line contains an integer n.
// Output
// Print a beautiful permutation of integers 1,2,...,n. If there
// are several solutions, you may print any of them. If there
// are no solutions, print "NO SOLUTION".  Constraints
// 1 <= n <= 10^6
// Example 1
// Input:
// 5
// Output:
// 4 2 5 3 1
// Example 2
// Input:
// 3
// Output:
// NO SOLUTION
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <bits/stdc++.h>
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
typedef int i32;
typedef unsigned int u32;
typedef long long i64;
typedef unsigned long long u64;
typedef vector<i32> vi32;
typedef vector<u32> vu32;
typedef vector<bool> vbool;
////////////////////////////////////////////////////////////////
constexpr char nl = '\n';
constexpr char sp = ' ';
////////////////////////////////////////////////////////////////
template <typename T>
istream& operator>>( istream& is, vector<T>& v ){
    for( auto& y: v ){ is >> y; }
    return is;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
inline void vrooom() {
    cin.tie( nullptr )->sync_with_stdio( false );
}
////////////////////////////////////////////////////////////////
template <typename T>
inline T load_scalar() {
    T y; cin >> y;
    return y;
}
////////////////////////////////////////////////////////////////
template <typename T>
inline vector<T> load_vector( int n ) {
    vector<T> y( n ); cin >> y;
    return y;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# define OVERLOAD_OSTREAM_OPERATOR( Container )                \
template <typename... T>                                       \
ostream& operator<<( ostream& os, const Container<T...>& con ){\
    os << "[ ";                                                \
    for( const auto& y: con ) os << y << " ";                  \
    return os <<"]";                                           \
}
////////////////////////////////////////////////////////////////
OVERLOAD_OSTREAM_OPERATOR( vector );
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main() {
    vrooom();
    auto n = load_scalar<u32>();
    if( n == 2 or n == 3 ){
        cout << "NO SOLUTION";
        return 0;
    }
    for( i32 i = 2; i <= n; i += 2 ){
        cout << i << sp;
    }
    for( i32 i = 1; i <= n; i += 2 ){
        cout << i << sp;
    }    
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
