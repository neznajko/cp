////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Two Sets
////////////////////////////////////////////////////////////////
// Time limit: 1.00 s
// Memory limit: 512 MB
////////////////////////////////////////////////////////////////
// Your task is to divide the numbers 1,2,...,n into two sets of
// equal sum.
////////////////////////////////////////////////////////////////
// Input
// The only input line contains an integer n.
// Output
// Print "YES", if the division is possible, and "NO" otherwise.
// After this, if the division is possible, print an example of
// how to create the sets. First, print the number of elements
// in the first set followed by the elements themselves in a
// separate line, and then, print the second set in a similar
// way.
////////////////////////////////////////////////////////////////
// Constraints
// 1 <= n <= 10^6
////////////////////////////////////////////////////////////////
// Example 1
// Input:
// 7
// Output:
// YES
// 4
// 1 2 4 7
// 3
// 3 5 6
// Example 2
// Input:
// 6
// Output:
// NO
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# include <bits/stdc++.h>
////////////////////////////////////////////////////////////////
using namespace std;
////////////////////////////////////////////////////////////////
using i32 = int;
using u32 = unsigned int;
using i64 = long long;
using u64 = unsigned long long;
using vi32 = vector<i32>;
using vu32 = vector<u32>;
using vi64 = vector<i64>;
using vu64 = vector<u64>;
using vb8l = vector<bool>;
////////////////////////////////////////////////////////////////
constexpr char nl = '\n';
constexpr char sp = ' ';
constexpr char tab = '\t';
////////////////////////////////////////////////////////////////
template <typename T>
istream& operator>>( istream& is, vector<T>& v ){
    for( auto& y: v ){ is >> y; }
    return is;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
inline void vrooom() {
    cin.tie( nullptr )->sync_with_stdio( false );
}
////////////////////////////////////////////////////////////////
template <typename T>
inline T load_scalar() {
    T y; cin >> y;
    return y;
}
////////////////////////////////////////////////////////////////
template <typename T>
inline vector<T> load_vector( int n ) {
    vector<T> y( n ); cin >> y;
    return y;
}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
string OPEN_BRACKET = "[";
string CLOSE_BRACKET = "]";
string SEPARATOR = ",";
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
# define OVERLOAD_OSTREAM_OPERATOR( Container )                \
template <typename... T>                                       \
ostream& operator<<( ostream& os, const Container<T...>& con ){\
    os << OPEN_BRACKET;                                        \
    string sep = "";                                           \
    for( const auto& y: con ){                                 \
        os << sep << y;                                        \
        sep = SEPARATOR;                                       \
    }                                                          \
    return os << CLOSE_BRACKET;                                \
}
////////////////////////////////////////////////////////////////
OVERLOAD_OSTREAM_OPERATOR( vector );
////////////////////////////////////////////////////////////////
# define FOR_THE_HORDE auto t = load_scalar<u32>(); while( t-- )
# define PSH push_back
# define POP pop_back
# define odd( x ) ((x) & 1)
# define evn( y ) (!odd( y ))
# define sqr( x ) ((x) * (x))
# define all( x ) x.begin(), x.end()
# define siz( y ) (u32) y.size()
# define dbg( x ) cerr << #x << " = " << x << nl
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
int main() {
    vrooom();
    OPEN_BRACKET = "";
    CLOSE_BRACKET = "";
    SEPARATOR = " ";
    auto n = load_scalar<u64>();
    auto s = n * (n + 1) / 2;
    if( odd( s )){ cout << "NO"; return 0; }
    s /= 2;
    vu64 a;
    u64 j = n;
    for(; s > 0; --j ){
        if( j <= s ){
            a.PSH( j );
            s -= j;
        } else {
            a.PSH( s );
            break;
        }
    }
    vu64 b;
    for(; j > 0; --j ){
        if( j == a.back()){ continue; }
        b.PSH( j );
    }
    cout << "YES" << nl
         << siz( a ) << nl << a << nl
         << siz( b ) << nl << b << nl;

}
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
